Memcached的Key，要杜绝使用空格，且长度控制在250个字符。
Memcached的Value，要控制体积，必须小于1MB，必要时进行使用压缩。
失效时间，0为永久有效，最大值不得超过30天（2592000s），否则重新计算可能缓存只有1秒
Memcached仅支持LRU算法，完全适用你的需要。
尽量不要将List这种重体积对象扔到Memcached中，传输、存储都会产生瓶颈。
使用一致性哈希算法实现，提高多个Memcacehd Server利用率。

关于SET&ADD 
SET&ADD都属于更新操作，都要先申请内存
SET，会擦除这个键所对应的内存，不管原先是否有内容
ADD，会先查看这个键对应的内存是否有内容，如果有，则等待；若没有，则获取锁，并更新内存。

缓存命中率，通常认为：缓存命中率低于95%的设计都是不合理的，存在设计缺陷的。 

可以在服务器上配置一个PHP页面来监测Memcached的情况， 
下载MemcachePHP 
如果不方便搭建PHP服务，可以使用Perl脚本memcache-top 
修改@default_instances或使用--instances参数： 
Shell代码  
perl memcache-top-v0.6 --instances 10.11.155.26 10.11.155.41  

private MemcachedClientBuilder createMemcachedClientBuilder(  
        Properties properties) {  
    String addresses = properties.getProperty(ADDRESSES).trim();  
  
    if (logger.isInfoEnabled()) {  
        logger.info("Configure Properties:[addresses = " + addresses + "]");  
    }  
    MemcachedClientBuilder builder = new XMemcachedClientBuilder(  
            AddrUtil.getAddresses(addresses));  
  
    // 使用二进制文件  
    builder.setCommandFactory(new BinaryCommandFactory());  
    // 使用一致性哈希算法（Consistent Hash Strategy）  
    builder.setSessionLocator(new KetamaMemcachedSessionLocator());  
    // 使用序列化传输编码  
    builder.setTranscoder(new SerializingTranscoder());  
    // 进行数据压缩，大于1KB时进行压缩  
    builder.getTranscoder().setCompressionThreshold(1024);  
  
    return builder;  
} 